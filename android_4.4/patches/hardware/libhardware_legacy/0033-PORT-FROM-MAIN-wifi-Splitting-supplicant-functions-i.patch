From cbca22bae1fa1405f2d1fc35c2516d59332b9d58 Mon Sep 17 00:00:00 2001
From: Jeremie GARCIA <jeremie.garcia@intel.com>
Date: Wed, 30 Oct 2013 15:51:35 +0100
Subject: [PORT FROM MAIN]wifi: Splitting supplicant functions in their own file

BZ: 125764

Change-Id: Ib835cc5bd866d55461aa648c30fca41fa9583e41
Orig-Change-Id: Id81301f228c3b84a58fbf9a05e44c13a65fd1a6f
Category: device enablement
Domain: CWS.WIFI-Common
Origin: internal
Upstream-Candidate: yes
Signed-off-by: Quentin Casasnovas <quentinx.casasnovas@intel.com>
Reviewed-on: http://android.intel.com:8080/120541
Reviewed-by: Champciaux, Nicolas <nicolas.champciaux@intel.com>
Tested-by: Champciaux, Nicolas <nicolas.champciaux@intel.com>
Reviewed-by: cactus <cactus@intel.com>
Tested-by: cactus <cactus@intel.com>
---
 wifi/Android.mk   |    1 +
 wifi/supplicant.c |  634 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 wifi/supplicant.h |   35 +++
 wifi/wifi.c       |  640 -----------------------------------------------------
 wifi/wifi.h       |    3 +
 5 files changed, 673 insertions(+), 640 deletions(-)
 create mode 100644 wifi/supplicant.c
 create mode 100644 wifi/supplicant.h

diff --git a/wifi/Android.mk b/wifi/Android.mk
index 2a9b906..d5be810 100644
--- a/wifi/Android.mk
+++ b/wifi/Android.mk
@@ -48,6 +48,7 @@ else
 
 	LOCAL_SRC_FILES += wifi/wifi.c
 	LOCAL_SRC_FILES += wifi/utils.c
+	LOCAL_SRC_FILES += wifi/supplicant.c
 endif
 
 endif
diff --git a/wifi/supplicant.c b/wifi/supplicant.c
new file mode 100644
index 0000000..81ecdf8
--- /dev/null
+++ b/wifi/supplicant.c
@@ -0,0 +1,634 @@
+/*
+ * Copyright 2008, The Android Open Source Project
+ * Copyright 2012-2013, Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "wifi.h"
+#include "supplicant.h"
+
+static struct wpa_ctrl *ctrl_conn;
+static struct wpa_ctrl *monitor_conn;
+
+/* socket pair used to exit from a blocking read */
+static int exit_sockets[2];
+
+static char primary_iface[PROPERTY_VALUE_MAX];
+
+static unsigned char dummy_key[21] = { 0x02, 0x11, 0xbe, 0x33, 0x43, 0x35,
+                                       0x68, 0x47, 0x84, 0x99, 0xa9, 0x2b,
+                                       0x1c, 0xd3, 0xee, 0xff, 0xf1, 0xe2,
+                                       0xf3, 0xf4, 0xf5 };
+
+static pthread_mutex_t suppl_mutex = PTHREAD_MUTEX_INITIALIZER;
+/* Is either SUPPLICANT_NAME or P2P_SUPPLICANT_NAME */
+static char supplicant_name[PROPERTY_VALUE_MAX];
+/* Is either SUPP_PROP_NAME or P2P_PROP_NAME */
+static char supplicant_prop_name[PROPERTY_KEY_MAX];
+
+static const char MODULE_FILE[]         = "/proc/modules";
+
+static const char IFNAME[]              = "IFNAME=";
+#define IFNAMELEN                      (sizeof(IFNAME) - 1)
+static const char WPA_EVENT_IGNORE[]    = "CTRL-EVENT-IGNORE ";
+
+int do_dhcp_request(int *ipaddr, int *gateway, int *mask,
+                    int *dns1, int *dns2, int *server, int *lease) {
+    /* For test driver, always report success */
+    if (strcmp(primary_iface, WIFI_TEST_INTERFACE) == 0)
+        return 0;
+
+    if (ifc_init() < 0)
+        return -1;
+
+    if (do_dhcp(primary_iface) < 0) {
+        ifc_close();
+        return -1;
+    }
+    ifc_close();
+    get_dhcp_info(ipaddr, gateway, mask, dns1, dns2, server, lease);
+    return 0;
+}
+
+const char *get_dhcp_error_string() {
+    return dhcp_lasterror();
+}
+
+int ensure_entropy_file_exists()
+{
+    int ret;
+    int destfd;
+
+    ret = access(SUPP_ENTROPY_FILE, R_OK|W_OK);
+    if ((ret == 0) || (errno == EACCES)) {
+        if ((ret != 0) &&
+            (chmod(SUPP_ENTROPY_FILE, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) != 0)) {
+            ALOGE("Cannot set RW to \"%s\": %s", SUPP_ENTROPY_FILE, strerror(errno));
+            return -1;
+        }
+        return 0;
+    }
+    destfd = TEMP_FAILURE_RETRY(open(SUPP_ENTROPY_FILE, O_CREAT|O_RDWR, 0660));
+    if (destfd < 0) {
+        ALOGE("Cannot create \"%s\": %s", SUPP_ENTROPY_FILE, strerror(errno));
+        return -1;
+    }
+
+    if (TEMP_FAILURE_RETRY(write(destfd, dummy_key, sizeof(dummy_key))) != sizeof(dummy_key)) {
+        ALOGE("Error writing \"%s\": %s", SUPP_ENTROPY_FILE, strerror(errno));
+        close(destfd);
+        return -1;
+    }
+    close(destfd);
+
+    /* chmod is needed because open() didn't set permisions properly */
+    if (chmod(SUPP_ENTROPY_FILE, 0660) < 0) {
+        ALOGE("Error changing permissions of %s to 0660: %s",
+             SUPP_ENTROPY_FILE, strerror(errno));
+        unlink(SUPP_ENTROPY_FILE);
+        return -1;
+    }
+
+    if (chown(SUPP_ENTROPY_FILE, AID_SYSTEM, AID_WIFI) < 0) {
+        ALOGE("Error changing group ownership of %s to %d: %s",
+             SUPP_ENTROPY_FILE, AID_WIFI, strerror(errno));
+        unlink(SUPP_ENTROPY_FILE);
+        return -1;
+    }
+    return 0;
+}
+
+int update_ctrl_interface(const char *config_file) {
+
+    int srcfd, destfd;
+    int nread;
+    char ifc[PROPERTY_VALUE_MAX];
+    char *pbuf;
+    char *sptr;
+    struct stat sb;
+    int ret;
+
+    if (stat(config_file, &sb) != 0)
+        return -1;
+
+    pbuf = malloc(sb.st_size + PROPERTY_VALUE_MAX);
+    if (!pbuf)
+        return 0;
+    srcfd = TEMP_FAILURE_RETRY(open(config_file, O_RDONLY));
+    if (srcfd < 0) {
+        ALOGE("Cannot open \"%s\": %s", config_file, strerror(errno));
+        free(pbuf);
+        return 0;
+    }
+    nread = TEMP_FAILURE_RETRY(read(srcfd, pbuf, sb.st_size));
+    close(srcfd);
+    if (nread < 0) {
+        ALOGE("Cannot read \"%s\": %s", config_file, strerror(errno));
+        free(pbuf);
+        return 0;
+    }
+
+    if (!strcmp(config_file, SUPP_CONFIG_FILE)) {
+        property_get("wifi.interface", ifc, WIFI_TEST_INTERFACE);
+    } else {
+        strcpy(ifc, CONTROL_IFACE_PATH);
+    }
+    /* Assume file is invalid to begin with */
+    ret = -1;
+    /*
+     * if there is a "ctrl_interface=<value>" entry, re-write it ONLY if it is
+     * NOT a directory.  The non-directory value option is an Android add-on
+     * that allows the control interface to be exchanged through an environment
+     * variable (initialized by the "init" program when it starts a service
+     * with a "socket" option).
+     *
+     * The <value> is deemed to be a directory if the "DIR=" form is used or
+     * the value begins with "/".
+     */
+    if ((sptr = strstr(pbuf, "ctrl_interface="))) {
+        ret = 0;
+        if ((!strstr(pbuf, "ctrl_interface=DIR=")) &&
+                (!strstr(pbuf, "ctrl_interface=/"))) {
+            char *iptr = sptr + strlen("ctrl_interface=");
+            int ilen = 0;
+            int mlen = strlen(ifc);
+            int nwrite;
+            if (strncmp(ifc, iptr, mlen) != 0) {
+                ALOGE("ctrl_interface != %s", ifc);
+                while (((ilen + (iptr - pbuf)) < nread) && (iptr[ilen] != '\n'))
+                    ilen++;
+                mlen = ((ilen >= mlen) ? ilen : mlen) + 1;
+                memmove(iptr + mlen, iptr + ilen + 1, nread - (iptr + ilen + 1 - pbuf));
+                memset(iptr, '\n', mlen);
+                memcpy(iptr, ifc, strlen(ifc));
+                destfd = TEMP_FAILURE_RETRY(open(config_file, O_RDWR, 0660));
+                if (destfd < 0) {
+                    ALOGE("Cannot update \"%s\": %s", config_file, strerror(errno));
+                    free(pbuf);
+                    return -1;
+                }
+                TEMP_FAILURE_RETRY(write(destfd, pbuf, nread + mlen - ilen -1));
+                close(destfd);
+            }
+        }
+    }
+    free(pbuf);
+    return ret;
+}
+
+int ensure_config_file_exists(const char *config_file)
+{
+    char buf[2048];
+    int srcfd, destfd;
+    struct stat sb;
+    int nread;
+    int ret;
+
+    ret = access(config_file, R_OK|W_OK);
+    if ((ret == 0) || (errno == EACCES)) {
+        if ((ret != 0) &&
+            (chmod(config_file, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) != 0)) {
+            ALOGE("Cannot set RW to \"%s\": %s", config_file, strerror(errno));
+            return -1;
+        }
+        /* return if we were able to update control interface properly */
+        if (update_ctrl_interface(config_file) >=0) {
+            return 0;
+        } else {
+            /* This handles the scenario where the file had bad data
+             * for some reason. We continue and recreate the file.
+             */
+        }
+    } else if (errno != ENOENT) {
+        ALOGE("Cannot access \"%s\": %s", config_file, strerror(errno));
+        return -1;
+    }
+
+    srcfd = TEMP_FAILURE_RETRY(open(SUPP_CONFIG_TEMPLATE, O_RDONLY));
+    if (srcfd < 0) {
+        ALOGE("Cannot open \"%s\": %s", SUPP_CONFIG_TEMPLATE, strerror(errno));
+        return -1;
+    }
+
+    destfd = TEMP_FAILURE_RETRY(open(config_file, O_CREAT|O_RDWR, 0660));
+    if (destfd < 0) {
+        close(srcfd);
+        ALOGE("Cannot create \"%s\": %s", config_file, strerror(errno));
+        return -1;
+    }
+
+    while ((nread = TEMP_FAILURE_RETRY(read(srcfd, buf, sizeof(buf)))) != 0) {
+        if (nread < 0) {
+            ALOGE("Error reading \"%s\": %s", SUPP_CONFIG_TEMPLATE, strerror(errno));
+            close(srcfd);
+            close(destfd);
+            unlink(config_file);
+            return -1;
+        }
+        TEMP_FAILURE_RETRY(write(destfd, buf, nread));
+    }
+
+    close(destfd);
+    close(srcfd);
+
+    /* chmod is needed because open() didn't set permisions properly */
+    if (chmod(config_file, 0660) < 0) {
+        ALOGE("Error changing permissions of %s to 0660: %s",
+             config_file, strerror(errno));
+        unlink(config_file);
+        return -1;
+    }
+
+    if (chown(config_file, AID_SYSTEM, AID_WIFI) < 0) {
+        ALOGE("Error changing group ownership of %s to %d: %s",
+             config_file, AID_WIFI, strerror(errno));
+        unlink(config_file);
+        return -1;
+    }
+    return update_ctrl_interface(config_file);
+}
+
+int wifi_start_supplicant(int p2p_supported)
+{
+    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
+    int count = 200; /* wait at most 20 seconds for completion */
+#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
+    const prop_info *pi;
+    unsigned serial = 0, i;
+#endif
+
+    if (p2p_supported) {
+        strcpy(supplicant_name, P2P_SUPPLICANT_NAME);
+        strcpy(supplicant_prop_name, P2P_PROP_NAME);
+
+        /* Ensure p2p config file is created */
+        if (ensure_config_file_exists(P2P_CONFIG_FILE) < 0) {
+            ALOGE("Failed to create a p2p config file");
+            return -1;
+        }
+
+    } else {
+        strcpy(supplicant_name, SUPPLICANT_NAME);
+        strcpy(supplicant_prop_name, SUPP_PROP_NAME);
+    }
+
+    /* Check whether already running */
+    if (property_get(supplicant_prop_name, supp_status, NULL)
+            && strcmp(supp_status, "running") == 0) {
+        return 0;
+    }
+
+    /* Before starting the daemon, make sure its config file exists */
+    if (ensure_config_file_exists(SUPP_CONFIG_FILE) < 0) {
+        ALOGE("Wi-Fi will not be enabled");
+        return -1;
+    }
+
+    if (ensure_entropy_file_exists() < 0) {
+        ALOGE("Wi-Fi entropy file was not created");
+    }
+
+    /* Clear out any stale socket files that might be left over. */
+    wpa_ctrl_cleanup();
+
+    /* Reset sockets used for exiting from hung state */
+    exit_sockets[0] = exit_sockets[1] = -1;
+
+#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
+    /*
+     * Get a reference to the status property, so we can distinguish
+     * the case where it goes stopped => running => stopped (i.e.,
+     * it start up, but fails right away) from the case in which
+     * it starts in the stopped state and never manages to start
+     * running at all.
+     */
+    pi = __system_property_find(supplicant_prop_name);
+    if (pi != NULL) {
+        serial = __system_property_serial(pi);
+    }
+#endif
+    property_get("wifi.interface", primary_iface, WIFI_TEST_INTERFACE);
+
+    property_set("ctl.start", supplicant_name);
+    sched_yield();
+
+    while (count-- > 0) {
+#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
+        if (pi == NULL) {
+            pi = __system_property_find(supplicant_prop_name);
+        }
+        if (pi != NULL) {
+            __system_property_read(pi, NULL, supp_status);
+            if (strcmp(supp_status, "running") == 0) {
+                return 0;
+            } else if (__system_property_serial(pi) != serial &&
+                    strcmp(supp_status, "stopped") == 0) {
+                return -1;
+            }
+        }
+#else
+        if (property_get(supplicant_prop_name, supp_status, NULL)) {
+            if (strcmp(supp_status, "running") == 0)
+                return 0;
+        }
+#endif
+        usleep(100000);
+    }
+    return -1;
+}
+
+int wifi_stop_supplicant(int p2p_supported)
+{
+    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
+    int count = 50; /* wait at most 5 seconds for completion */
+    char pidpropname[] = "wpa_supplicant.pid";
+    char pidpropval[PROPERTY_VALUE_MAX];
+    int ret, pid;
+
+    if (p2p_supported) {
+        strcpy(supplicant_name, P2P_SUPPLICANT_NAME);
+        strcpy(supplicant_prop_name, P2P_PROP_NAME);
+    } else {
+        strcpy(supplicant_name, SUPPLICANT_NAME);
+        strcpy(supplicant_prop_name, SUPP_PROP_NAME);
+    }
+
+    /* Check whether supplicant already stopped */
+    if (property_get(supplicant_prop_name, supp_status, NULL)
+        && strcmp(supp_status, "stopped") == 0) {
+        return 0;
+    }
+
+    /* Shutdown wpa_supplicant with SIGTERM signal instead of
+     * SIGKILL sent by ctl.stop system command .
+     * SIGTERM allows to deinit properly all the wifi interfaces,
+     * specially p2p0 and p2p-p2p0-X virtual interfaces. It fixes
+     * further p2p connections after an Android framework softreboot
+     */
+
+    property_get(pidpropname, pidpropval, "-1");
+    pid = atoi(pidpropval);
+
+    LOGD("wpa_supplicant pid %d", pid);
+    if (pid > 0) {
+        /* try a nice wpa_supplicant shutdown */
+        ret = kill(pid, SIGTERM);
+        if (ret == 0) {
+            waitpid(pid, NULL, 0);
+            usleep(800000);
+            LOGD("wpa_supplicant pid %d stopped with SIGTERM", pid);
+            property_set(pidpropname, "");
+        } else {
+            LOGE("wpa_supplicant pid %d failed to stop", pid);
+        }
+    }
+    property_set("ctl.stop", supplicant_name);
+    sched_yield();
+
+    while (count-- > 0) {
+        if (property_get(supplicant_prop_name, supp_status, NULL)) {
+            if (strcmp(supp_status, "stopped") == 0)
+                return 0;
+        }
+        usleep(100000);
+    }
+    ALOGE("Failed to stop supplicant");
+    return -1;
+}
+int wifi_connect_on_socket_path(const char *path)
+{
+    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
+
+    /* Make sure supplicant is running */
+    if (!property_get(supplicant_prop_name, supp_status, NULL)
+            || strcmp(supp_status, "running") != 0) {
+        ALOGE("Supplicant not running, cannot connect");
+        return -1;
+    }
+
+    ctrl_conn = wpa_ctrl_open(path);
+    if (ctrl_conn == NULL) {
+        ALOGE("Unable to open connection to supplicant on \"%s\": %s",
+             path, strerror(errno));
+        return -1;
+    }
+    monitor_conn = wpa_ctrl_open(path);
+    if (monitor_conn == NULL) {
+        wpa_ctrl_close(ctrl_conn);
+        ctrl_conn = NULL;
+        return -1;
+    }
+    if (wpa_ctrl_attach(monitor_conn) != 0) {
+        wpa_ctrl_close(monitor_conn);
+        wpa_ctrl_close(ctrl_conn);
+        ctrl_conn = monitor_conn = NULL;
+        return -1;
+    }
+
+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, exit_sockets) == -1) {
+        wpa_ctrl_close(monitor_conn);
+        wpa_ctrl_close(ctrl_conn);
+        ctrl_conn = monitor_conn = NULL;
+        return -1;
+    }
+
+    return 0;
+}
+
+/* Establishes the control and monitor socket connections on the interface */
+int wifi_connect_to_supplicant()
+{
+    static char path[PATH_MAX];
+
+    if (access(IFACE_DIR, F_OK) == 0) {
+        snprintf(path, sizeof(path), "%s/%s", IFACE_DIR, primary_iface);
+    } else {
+        snprintf(path, sizeof(path), "@android:wpa_%s", primary_iface);
+    }
+    return wifi_connect_on_socket_path(path);
+}
+
+int wifi_send_command(const char *cmd, char *reply, size_t *reply_len)
+{
+    int ret;
+    if (ctrl_conn == NULL) {
+        ALOGV("Not connected to wpa_supplicant - \"%s\" command dropped.\n", cmd);
+        return -1;
+    }
+    log_cmd(cmd);
+    ret = wpa_ctrl_request(ctrl_conn, cmd, strlen(cmd), reply, reply_len, NULL);
+    if (ret == -2) {
+        ALOGD("'%s' command timed out.\n", cmd);
+        /* unblocks the monitor receive socket for termination */
+        TEMP_FAILURE_RETRY(write(exit_sockets[0], "T", 1));
+        return -2;
+    } else if (ret < 0 || strncmp(reply, "FAIL", 4) == 0) {
+        LOGI("REPLY: FAIL\n");
+        return -1;
+    }
+    if (strncmp(cmd, "PING", 4) == 0) {
+        reply[*reply_len] = '\0';
+    }
+    log_reply(reply, reply_len);
+    return 0;
+}
+
+int wifi_ctrl_recv(char *reply, size_t *reply_len)
+{
+    int res;
+    int ctrlfd = wpa_ctrl_get_fd(monitor_conn);
+    struct pollfd rfds[2];
+
+    memset(rfds, 0, 2 * sizeof(struct pollfd));
+    rfds[0].fd = ctrlfd;
+    rfds[0].events |= POLLIN;
+    rfds[1].fd = exit_sockets[1];
+    rfds[1].events |= POLLIN;
+    res = TEMP_FAILURE_RETRY(poll(rfds, 2, -1));
+    if (res < 0) {
+        ALOGE("Error poll = %d", res);
+        return res;
+    }
+    if (rfds[0].revents & POLLIN) {
+        return wpa_ctrl_recv(monitor_conn, reply, reply_len);
+    }
+
+    /* it is not rfds[0], then it must be rfts[1] (i.e. the exit socket)
+     * or we timed out. In either case, this call has failed ..
+     */
+    return -2;
+}
+
+int wifi_wait_on_socket(char *buf, size_t buflen)
+{
+    size_t nread = buflen - 1;
+    int result;
+    char *match, *match2;
+
+    if (monitor_conn == NULL) {
+        return snprintf(buf, buflen, WPA_EVENT_TERMINATING " - connection closed");
+    }
+
+    result = wifi_ctrl_recv(buf, &nread);
+
+    /* Terminate reception on exit socket */
+    if (result == -2) {
+        return snprintf(buf, buflen, WPA_EVENT_TERMINATING " - connection closed");
+    }
+
+    if (result < 0) {
+        ALOGD("wifi_ctrl_recv failed: %s\n", strerror(errno));
+        return snprintf(buf, buflen, WPA_EVENT_TERMINATING " - recv error");
+    }
+    buf[nread] = '\0';
+    /* Check for EOF on the socket */
+    if (result == 0 && nread == 0) {
+        /* Fabricate an event to pass up */
+        ALOGD("Received EOF on supplicant socket\n");
+        return snprintf(buf, buflen, WPA_EVENT_TERMINATING " - signal 0 received");
+    }
+    /*
+     * Events strings are in the format
+     *
+     *     IFNAME=iface <N>CTRL-EVENT-XXX 
+     *        or
+     *     <N>CTRL-EVENT-XXX 
+     *
+     * where N is the message level in numerical form (0=VERBOSE, 1=DEBUG,
+     * etc.) and XXX is the event name. The level information is not useful
+     * to us, so strip it off.
+     */
+
+    if (strncmp(buf, IFNAME, IFNAMELEN) == 0) {
+        match = strchr(buf, ' ');
+        if (match != NULL) {
+            if (match[1] == '<') {
+                match2 = strchr(match + 2, '>');
+                if (match2 != NULL) {
+                    nread -= (match2 - match);
+                    memmove(match + 1, match2 + 1, nread - (match - buf) + 1);
+                }
+            }
+        } else {
+            return snprintf(buf, buflen, "%s", WPA_EVENT_IGNORE);
+        }
+    } else if (buf[0] == '<') {
+        match = strchr(buf, '>');
+        if (match != NULL) {
+            nread -= (match + 1 - buf);
+            memmove(buf, match + 1, nread + 1);
+            ALOGV("supplicant generated event without interface - %s\n", buf);
+        }
+    } else {
+        /* let the event go as is! */
+        ALOGW("supplicant generated event without interface and without message level - %s\n", buf);
+    }
+    LOGI("EVENT: %s\n", buf);
+    return nread;
+}
+
+int wifi_wait_for_event(char *buf, size_t buflen)
+{
+    return wifi_wait_on_socket(buf, buflen);
+}
+
+void wifi_close_sockets()
+{
+    if (ctrl_conn != NULL) {
+        wpa_ctrl_close(ctrl_conn);
+        ctrl_conn = NULL;
+    }
+
+    if (monitor_conn != NULL) {
+        wpa_ctrl_close(monitor_conn);
+        monitor_conn = NULL;
+    }
+
+    if (exit_sockets[0] >= 0) {
+        close(exit_sockets[0]);
+        exit_sockets[0] = -1;
+    }
+
+    if (exit_sockets[1] >= 0) {
+        close(exit_sockets[1]);
+        exit_sockets[1] = -1;
+    }
+}
+
+void wifi_close_supplicant_connection()
+{
+    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
+    int count = 50; /* wait at most 5 seconds to ensure init has stopped stupplicant */
+    LOGD("Close connection to supplicant\n");
+    pthread_mutex_lock(&suppl_mutex);
+
+    wifi_close_sockets();
+        pthread_mutex_unlock(&suppl_mutex);
+
+    while (count-- > 0) {
+        if (property_get(supplicant_prop_name, supp_status, NULL)) {
+            if (strcmp(supp_status, "stopped") == 0) {
+                pthread_mutex_unlock(&suppl_mutex);
+                return;
+	    }
+        }
+        usleep(100000);
+    }
+    pthread_mutex_unlock(&suppl_mutex);
+}
+
+int wifi_command(const char *command, char *reply, size_t *reply_len)
+{
+    return wifi_send_command(command, reply, reply_len);
+}
diff --git a/wifi/supplicant.h b/wifi/supplicant.h
new file mode 100644
index 0000000..17770b0
--- /dev/null
+++ b/wifi/supplicant.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2008, The Android Open Source Project
+ * Copyright 2012-2013, Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SUPPLICANT_H_
+# define SUPPLICANT_H_
+
+# include <sys/types.h>
+# include <sys/wait.h>
+
+#define IFACE_DIR                       "/data/system/wpa_supplicant"
+#define SUPPLICANT_NAME                 "wpa_supplicant"
+#define SUPP_PROP_NAME                  "init.svc.wpa_supplicant"
+#define P2P_SUPPLICANT_NAME             "p2p_supplicant"
+#define P2P_PROP_NAME                   "init.svc.p2p_supplicant"
+#define SUPP_CONFIG_TEMPLATE            "/system/etc/wifi/wpa_supplicant.conf"
+#define SUPP_CONFIG_FILE                "/data/misc/wifi/wpa_supplicant.conf"
+#define P2P_CONFIG_FILE                 "/data/misc/wifi/p2p_supplicant.conf"
+#define CONTROL_IFACE_PATH              "/data/misc/wifi/sockets"
+#define SUPP_ENTROPY_FILE               WIFI_ENTROPY_FILE
+
+#endif /* !SUPPLICANT_H_ */
diff --git a/wifi/wifi.c b/wifi/wifi.c
index cb9e9dd..952caf2 100644
--- a/wifi/wifi.c
+++ b/wifi/wifi.c
@@ -16,82 +16,14 @@
 
 #include "wifi.h"
 
-static struct wpa_ctrl *ctrl_conn;
-static struct wpa_ctrl *monitor_conn;
-
-/* socket pair used to exit from a blocking read */
-static int exit_sockets[2];
-
-static char primary_iface[PROPERTY_VALUE_MAX];
-// TODO: use new ANDROID_SOCKET mechanism, once support for multiple
-// sockets is in
-
 #define WIFI_DRIVER_LOADER_DELAY	1000000
 
-static const char IFACE_DIR[]           = "/data/system/wpa_supplicant";
-#ifdef WIFI_DRIVER_MODULE_PATH
-static const char DRIVER_MODULE_NAME[]  = WIFI_DRIVER_MODULE_NAME;
-static const char DRIVER_MODULE_TAG[]   = WIFI_DRIVER_MODULE_NAME " ";
-static const char DRIVER_MODULE_PATH[]  = WIFI_DRIVER_MODULE_PATH;
-static const char DRIVER_MODULE_ARG[]   = WIFI_DRIVER_MODULE_ARG;
-#endif
-static const char FIRMWARE_LOADER[]     = WIFI_FIRMWARE_LOADER;
-static const char DRIVER_PROP_NAME[]    = "wlan.driver.status";
-static const char SUPPLICANT_NAME[]     = "wpa_supplicant";
-static const char SUPP_PROP_NAME[]      = "init.svc.wpa_supplicant";
-static const char P2P_SUPPLICANT_NAME[] = "p2p_supplicant";
-static const char P2P_PROP_NAME[]       = "init.svc.p2p_supplicant";
-static const char SUPP_CONFIG_TEMPLATE[]= "/system/etc/wifi/wpa_supplicant.conf";
-static const char SUPP_CONFIG_FILE[]    = "/data/misc/wifi/wpa_supplicant.conf";
-static const char P2P_CONFIG_FILE[]     = "/data/misc/wifi/p2p_supplicant.conf";
-static const char CONTROL_IFACE_PATH[]  = "/data/misc/wifi/sockets";
-static const char MODULE_FILE[]         = "/proc/modules";
-
-static const char IFNAME[]              = "IFNAME=";
-#define IFNAMELEN			(sizeof(IFNAME) - 1)
-static const char WPA_EVENT_IGNORE[]    = "CTRL-EVENT-IGNORE ";
-
 /*
  * This gets defined by the script load_bcmdriver in
  * vendor/intel/common/wifi/bcm_specific/
  */
 static const char BCM_PROP_CHIP[]	= "wlan.bcm.chip";
 
-static const char SUPP_ENTROPY_FILE[]   = WIFI_ENTROPY_FILE;
-static unsigned char dummy_key[21] = { 0x02, 0x11, 0xbe, 0x33, 0x43, 0x35,
-                                       0x68, 0x47, 0x84, 0x99, 0xa9, 0x2b,
-                                       0x1c, 0xd3, 0xee, 0xff, 0xf1, 0xe2,
-                                       0xf3, 0xf4, 0xf5 };
-
-static pthread_mutex_t suppl_mutex = PTHREAD_MUTEX_INITIALIZER;
-/* Is either SUPPLICANT_NAME or P2P_SUPPLICANT_NAME */
-static char supplicant_name[PROPERTY_VALUE_MAX];
-/* Is either SUPP_PROP_NAME or P2P_PROP_NAME */
-static char supplicant_prop_name[PROPERTY_KEY_MAX];
-
-
-int do_dhcp_request(int *ipaddr, int *gateway, int *mask,
-                    int *dns1, int *dns2, int *server, int *lease) {
-    /* For test driver, always report success */
-    if (strcmp(primary_iface, WIFI_TEST_INTERFACE) == 0)
-        return 0;
-
-    if (ifc_init() < 0)
-        return -1;
-
-    if (do_dhcp(primary_iface) < 0) {
-        ifc_close();
-        return -1;
-    }
-    ifc_close();
-    get_dhcp_info(ipaddr, gateway, mask, dns1, dns2, server, lease);
-    return 0;
-}
-
-const char *get_dhcp_error_string() {
-    return dhcp_lasterror();
-}
-
 int is_wifi_driver_loaded() {
     char driver_status[PROPERTY_VALUE_MAX];
 #ifdef WIFI_DRIVER_MODULE_PATH
@@ -194,577 +126,6 @@ int wifi_unload_driver()
 #endif
 }
 
-int ensure_entropy_file_exists()
-{
-    int ret;
-    int destfd;
-
-    ret = access(SUPP_ENTROPY_FILE, R_OK|W_OK);
-    if ((ret == 0) || (errno == EACCES)) {
-        if ((ret != 0) &&
-            (chmod(SUPP_ENTROPY_FILE, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) != 0)) {
-            ALOGE("Cannot set RW to \"%s\": %s", SUPP_ENTROPY_FILE, strerror(errno));
-            return -1;
-        }
-        return 0;
-    }
-    destfd = TEMP_FAILURE_RETRY(open(SUPP_ENTROPY_FILE, O_CREAT|O_RDWR, 0660));
-    if (destfd < 0) {
-        ALOGE("Cannot create \"%s\": %s", SUPP_ENTROPY_FILE, strerror(errno));
-        return -1;
-    }
-
-    if (TEMP_FAILURE_RETRY(write(destfd, dummy_key, sizeof(dummy_key))) != sizeof(dummy_key)) {
-        ALOGE("Error writing \"%s\": %s", SUPP_ENTROPY_FILE, strerror(errno));
-        close(destfd);
-        return -1;
-    }
-    close(destfd);
-
-    /* chmod is needed because open() didn't set permisions properly */
-    if (chmod(SUPP_ENTROPY_FILE, 0660) < 0) {
-        ALOGE("Error changing permissions of %s to 0660: %s",
-             SUPP_ENTROPY_FILE, strerror(errno));
-        unlink(SUPP_ENTROPY_FILE);
-        return -1;
-    }
-
-    if (chown(SUPP_ENTROPY_FILE, AID_SYSTEM, AID_WIFI) < 0) {
-        ALOGE("Error changing group ownership of %s to %d: %s",
-             SUPP_ENTROPY_FILE, AID_WIFI, strerror(errno));
-        unlink(SUPP_ENTROPY_FILE);
-        return -1;
-    }
-    return 0;
-}
-
-int update_ctrl_interface(const char *config_file) {
-
-    int srcfd, destfd;
-    int nread;
-    char ifc[PROPERTY_VALUE_MAX];
-    char *pbuf;
-    char *sptr;
-    struct stat sb;
-    int ret;
-
-    if (stat(config_file, &sb) != 0)
-        return -1;
-
-    pbuf = malloc(sb.st_size + PROPERTY_VALUE_MAX);
-    if (!pbuf)
-        return 0;
-    srcfd = TEMP_FAILURE_RETRY(open(config_file, O_RDONLY));
-    if (srcfd < 0) {
-        ALOGE("Cannot open \"%s\": %s", config_file, strerror(errno));
-        free(pbuf);
-        return 0;
-    }
-    nread = TEMP_FAILURE_RETRY(read(srcfd, pbuf, sb.st_size));
-    close(srcfd);
-    if (nread < 0) {
-        ALOGE("Cannot read \"%s\": %s", config_file, strerror(errno));
-        free(pbuf);
-        return 0;
-    }
-
-    if (!strcmp(config_file, SUPP_CONFIG_FILE)) {
-        property_get("wifi.interface", ifc, WIFI_TEST_INTERFACE);
-    } else {
-        strcpy(ifc, CONTROL_IFACE_PATH);
-    }
-    /* Assume file is invalid to begin with */
-    ret = -1;
-    /*
-     * if there is a "ctrl_interface=<value>" entry, re-write it ONLY if it is
-     * NOT a directory.  The non-directory value option is an Android add-on
-     * that allows the control interface to be exchanged through an environment
-     * variable (initialized by the "init" program when it starts a service
-     * with a "socket" option).
-     *
-     * The <value> is deemed to be a directory if the "DIR=" form is used or
-     * the value begins with "/".
-     */
-    if ((sptr = strstr(pbuf, "ctrl_interface="))) {
-        ret = 0;
-        if ((!strstr(pbuf, "ctrl_interface=DIR=")) &&
-                (!strstr(pbuf, "ctrl_interface=/"))) {
-            char *iptr = sptr + strlen("ctrl_interface=");
-            int ilen = 0;
-            int mlen = strlen(ifc);
-            int nwrite;
-            if (strncmp(ifc, iptr, mlen) != 0) {
-                ALOGE("ctrl_interface != %s", ifc);
-                while (((ilen + (iptr - pbuf)) < nread) && (iptr[ilen] != '\n'))
-                    ilen++;
-                mlen = ((ilen >= mlen) ? ilen : mlen) + 1;
-                memmove(iptr + mlen, iptr + ilen + 1, nread - (iptr + ilen + 1 - pbuf));
-                memset(iptr, '\n', mlen);
-                memcpy(iptr, ifc, strlen(ifc));
-                destfd = TEMP_FAILURE_RETRY(open(config_file, O_RDWR, 0660));
-                if (destfd < 0) {
-                    ALOGE("Cannot update \"%s\": %s", config_file, strerror(errno));
-                    free(pbuf);
-                    return -1;
-                }
-                TEMP_FAILURE_RETRY(write(destfd, pbuf, nread + mlen - ilen -1));
-                close(destfd);
-            }
-        }
-    }
-    free(pbuf);
-    return ret;
-}
-
-int ensure_config_file_exists(const char *config_file)
-{
-    char buf[2048];
-    int srcfd, destfd;
-    struct stat sb;
-    int nread;
-    int ret;
-
-    ret = access(config_file, R_OK|W_OK);
-    if ((ret == 0) || (errno == EACCES)) {
-        if ((ret != 0) &&
-            (chmod(config_file, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) != 0)) {
-            ALOGE("Cannot set RW to \"%s\": %s", config_file, strerror(errno));
-            return -1;
-        }
-        /* return if we were able to update control interface properly */
-        if (update_ctrl_interface(config_file) >=0) {
-            return 0;
-        } else {
-            /* This handles the scenario where the file had bad data
-             * for some reason. We continue and recreate the file.
-             */
-        }
-    } else if (errno != ENOENT) {
-        ALOGE("Cannot access \"%s\": %s", config_file, strerror(errno));
-        return -1;
-    }
-
-    srcfd = TEMP_FAILURE_RETRY(open(SUPP_CONFIG_TEMPLATE, O_RDONLY));
-    if (srcfd < 0) {
-        ALOGE("Cannot open \"%s\": %s", SUPP_CONFIG_TEMPLATE, strerror(errno));
-        return -1;
-    }
-
-    destfd = TEMP_FAILURE_RETRY(open(config_file, O_CREAT|O_RDWR, 0660));
-    if (destfd < 0) {
-        close(srcfd);
-        ALOGE("Cannot create \"%s\": %s", config_file, strerror(errno));
-        return -1;
-    }
-
-    while ((nread = TEMP_FAILURE_RETRY(read(srcfd, buf, sizeof(buf)))) != 0) {
-        if (nread < 0) {
-            ALOGE("Error reading \"%s\": %s", SUPP_CONFIG_TEMPLATE, strerror(errno));
-            close(srcfd);
-            close(destfd);
-            unlink(config_file);
-            return -1;
-        }
-        TEMP_FAILURE_RETRY(write(destfd, buf, nread));
-    }
-
-    close(destfd);
-    close(srcfd);
-
-    /* chmod is needed because open() didn't set permisions properly */
-    if (chmod(config_file, 0660) < 0) {
-        ALOGE("Error changing permissions of %s to 0660: %s",
-             config_file, strerror(errno));
-        unlink(config_file);
-        return -1;
-    }
-
-    if (chown(config_file, AID_SYSTEM, AID_WIFI) < 0) {
-        ALOGE("Error changing group ownership of %s to %d: %s",
-             config_file, AID_WIFI, strerror(errno));
-        unlink(config_file);
-        return -1;
-    }
-    return update_ctrl_interface(config_file);
-}
-
-int wifi_start_supplicant(int p2p_supported)
-{
-    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
-    int count = 200; /* wait at most 20 seconds for completion */
-#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
-    const prop_info *pi;
-    unsigned serial = 0, i;
-#endif
-
-    if (p2p_supported) {
-        strcpy(supplicant_name, P2P_SUPPLICANT_NAME);
-        strcpy(supplicant_prop_name, P2P_PROP_NAME);
-
-        /* Ensure p2p config file is created */
-        if (ensure_config_file_exists(P2P_CONFIG_FILE) < 0) {
-            ALOGE("Failed to create a p2p config file");
-            return -1;
-        }
-
-    } else {
-        strcpy(supplicant_name, SUPPLICANT_NAME);
-        strcpy(supplicant_prop_name, SUPP_PROP_NAME);
-    }
-
-    /* Check whether already running */
-    if (property_get(supplicant_prop_name, supp_status, NULL)
-            && strcmp(supp_status, "running") == 0) {
-        return 0;
-    }
-
-    /* Before starting the daemon, make sure its config file exists */
-    if (ensure_config_file_exists(SUPP_CONFIG_FILE) < 0) {
-        ALOGE("Wi-Fi will not be enabled");
-        return -1;
-    }
-
-    if (ensure_entropy_file_exists() < 0) {
-        ALOGE("Wi-Fi entropy file was not created");
-    }
-
-    /* Clear out any stale socket files that might be left over. */
-    wpa_ctrl_cleanup();
-
-    /* Reset sockets used for exiting from hung state */
-    exit_sockets[0] = exit_sockets[1] = -1;
-
-#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
-    /*
-     * Get a reference to the status property, so we can distinguish
-     * the case where it goes stopped => running => stopped (i.e.,
-     * it start up, but fails right away) from the case in which
-     * it starts in the stopped state and never manages to start
-     * running at all.
-     */
-    pi = __system_property_find(supplicant_prop_name);
-    if (pi != NULL) {
-        serial = __system_property_serial(pi);
-    }
-#endif
-    property_get("wifi.interface", primary_iface, WIFI_TEST_INTERFACE);
-
-    property_set("ctl.start", supplicant_name);
-    sched_yield();
-
-    while (count-- > 0) {
-#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
-        if (pi == NULL) {
-            pi = __system_property_find(supplicant_prop_name);
-        }
-        if (pi != NULL) {
-            __system_property_read(pi, NULL, supp_status);
-            if (strcmp(supp_status, "running") == 0) {
-                return 0;
-            } else if (__system_property_serial(pi) != serial &&
-                    strcmp(supp_status, "stopped") == 0) {
-                return -1;
-            }
-        }
-#else
-        if (property_get(supplicant_prop_name, supp_status, NULL)) {
-            if (strcmp(supp_status, "running") == 0)
-                return 0;
-        }
-#endif
-        usleep(100000);
-    }
-    return -1;
-}
-
-int wifi_stop_supplicant(int p2p_supported)
-{
-    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
-    int count = 50; /* wait at most 5 seconds for completion */
-    char pidpropname[] = "wpa_supplicant.pid";
-    char pidpropval[PROPERTY_VALUE_MAX];
-    int ret, pid;
-
-    if (p2p_supported) {
-        strcpy(supplicant_name, P2P_SUPPLICANT_NAME);
-        strcpy(supplicant_prop_name, P2P_PROP_NAME);
-    } else {
-        strcpy(supplicant_name, SUPPLICANT_NAME);
-        strcpy(supplicant_prop_name, SUPP_PROP_NAME);
-    }
-
-    /* Check whether supplicant already stopped */
-    if (property_get(supplicant_prop_name, supp_status, NULL)
-        && strcmp(supp_status, "stopped") == 0) {
-        return 0;
-    }
-
-    /* Shutdown wpa_supplicant with SIGTERM signal instead of
-     * SIGKILL sent by ctl.stop system command .
-     * SIGTERM allows to deinit properly all the wifi interfaces,
-     * specially p2p0 and p2p-p2p0-X virtual interfaces. It fixes
-     * further p2p connections after an Android framework softreboot
-     */
-
-    property_get(pidpropname, pidpropval, "-1");
-    pid = atoi(pidpropval);
-
-    LOGD("wpa_supplicant pid %d", pid);
-    if (pid > 0) {
-        /* try a nice wpa_supplicant shutdown */
-        ret = kill(pid, SIGTERM);
-        if (ret == 0) {
-            waitpid(pid, NULL, 0);
-            usleep(800000);
-            LOGD("wpa_supplicant pid %d stopped with SIGTERM", pid);
-            property_set(pidpropname, "");
-        } else {
-            LOGE("wpa_supplicant pid %d failed to stop", pid);
-        }
-    }
-    property_set("ctl.stop", supplicant_name);
-    sched_yield();
-
-    while (count-- > 0) {
-        if (property_get(supplicant_prop_name, supp_status, NULL)) {
-            if (strcmp(supp_status, "stopped") == 0)
-                return 0;
-        }
-        usleep(100000);
-    }
-    ALOGE("Failed to stop supplicant");
-    return -1;
-}
-
-int wifi_connect_on_socket_path(const char *path)
-{
-    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
-
-    /* Make sure supplicant is running */
-    if (!property_get(supplicant_prop_name, supp_status, NULL)
-            || strcmp(supp_status, "running") != 0) {
-        ALOGE("Supplicant not running, cannot connect");
-        return -1;
-    }
-
-    ctrl_conn = wpa_ctrl_open(path);
-    if (ctrl_conn == NULL) {
-        ALOGE("Unable to open connection to supplicant on \"%s\": %s",
-             path, strerror(errno));
-        return -1;
-    }
-    monitor_conn = wpa_ctrl_open(path);
-    if (monitor_conn == NULL) {
-        wpa_ctrl_close(ctrl_conn);
-        ctrl_conn = NULL;
-        return -1;
-    }
-    if (wpa_ctrl_attach(monitor_conn) != 0) {
-        wpa_ctrl_close(monitor_conn);
-        wpa_ctrl_close(ctrl_conn);
-        ctrl_conn = monitor_conn = NULL;
-        return -1;
-    }
-
-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, exit_sockets) == -1) {
-        wpa_ctrl_close(monitor_conn);
-        wpa_ctrl_close(ctrl_conn);
-        ctrl_conn = monitor_conn = NULL;
-        return -1;
-    }
-
-    return 0;
-}
-
-/* Establishes the control and monitor socket connections on the interface */
-int wifi_connect_to_supplicant()
-{
-    static char path[PATH_MAX];
-
-    if (access(IFACE_DIR, F_OK) == 0) {
-        snprintf(path, sizeof(path), "%s/%s", IFACE_DIR, primary_iface);
-    } else {
-        snprintf(path, sizeof(path), "@android:wpa_%s", primary_iface);
-    }
-    return wifi_connect_on_socket_path(path);
-}
-
-
-
-int wifi_send_command(const char *cmd, char *reply, size_t *reply_len)
-{
-    int ret;
-    if (ctrl_conn == NULL) {
-        ALOGV("Not connected to wpa_supplicant - \"%s\" command dropped.\n", cmd);
-        return -1;
-    }
-    log_cmd(cmd);
-    ret = wpa_ctrl_request(ctrl_conn, cmd, strlen(cmd), reply, reply_len, NULL);
-    if (ret == -2) {
-        ALOGD("'%s' command timed out.\n", cmd);
-        /* unblocks the monitor receive socket for termination */
-        TEMP_FAILURE_RETRY(write(exit_sockets[0], "T", 1));
-        return -2;
-    } else if (ret < 0 || strncmp(reply, "FAIL", 4) == 0) {
-        LOGI("REPLY: FAIL\n");
-        return -1;
-    }
-    if (strncmp(cmd, "PING", 4) == 0) {
-        reply[*reply_len] = '\0';
-    }
-    log_reply(reply, reply_len);
-    return 0;
-}
-
-int wifi_ctrl_recv(char *reply, size_t *reply_len)
-{
-    int res;
-    int ctrlfd = wpa_ctrl_get_fd(monitor_conn);
-    struct pollfd rfds[2];
-
-    memset(rfds, 0, 2 * sizeof(struct pollfd));
-    rfds[0].fd = ctrlfd;
-    rfds[0].events |= POLLIN;
-    rfds[1].fd = exit_sockets[1];
-    rfds[1].events |= POLLIN;
-    res = TEMP_FAILURE_RETRY(poll(rfds, 2, -1));
-    if (res < 0) {
-        ALOGE("Error poll = %d", res);
-        return res;
-    }
-    if (rfds[0].revents & POLLIN) {
-        return wpa_ctrl_recv(monitor_conn, reply, reply_len);
-    }
-
-    /* it is not rfds[0], then it must be rfts[1] (i.e. the exit socket)
-     * or we timed out. In either case, this call has failed ..
-     */
-    return -2;
-}
-
-int wifi_wait_on_socket(char *buf, size_t buflen)
-{
-    size_t nread = buflen - 1;
-    int result;
-    char *match, *match2;
-
-    if (monitor_conn == NULL) {
-        return snprintf(buf, buflen, WPA_EVENT_TERMINATING " - connection closed");
-    }
-
-    result = wifi_ctrl_recv(buf, &nread);
-
-    /* Terminate reception on exit socket */
-    if (result == -2) {
-        return snprintf(buf, buflen, WPA_EVENT_TERMINATING " - connection closed");
-    }
-
-    if (result < 0) {
-        ALOGD("wifi_ctrl_recv failed: %s\n", strerror(errno));
-        return snprintf(buf, buflen, WPA_EVENT_TERMINATING " - recv error");
-    }
-    buf[nread] = '\0';
-    /* Check for EOF on the socket */
-    if (result == 0 && nread == 0) {
-        /* Fabricate an event to pass up */
-        ALOGD("Received EOF on supplicant socket\n");
-        return snprintf(buf, buflen, WPA_EVENT_TERMINATING " - signal 0 received");
-    }
-    /*
-     * Events strings are in the format
-     *
-     *     IFNAME=iface <N>CTRL-EVENT-XXX 
-     *        or
-     *     <N>CTRL-EVENT-XXX 
-     *
-     * where N is the message level in numerical form (0=VERBOSE, 1=DEBUG,
-     * etc.) and XXX is the event name. The level information is not useful
-     * to us, so strip it off.
-     */
-
-    if (strncmp(buf, IFNAME, IFNAMELEN) == 0) {
-        match = strchr(buf, ' ');
-        if (match != NULL) {
-            if (match[1] == '<') {
-                match2 = strchr(match + 2, '>');
-                if (match2 != NULL) {
-                    nread -= (match2 - match);
-                    memmove(match + 1, match2 + 1, nread - (match - buf) + 1);
-                }
-            }
-        } else {
-            return snprintf(buf, buflen, "%s", WPA_EVENT_IGNORE);
-        }
-    } else if (buf[0] == '<') {
-        match = strchr(buf, '>');
-        if (match != NULL) {
-            nread -= (match + 1 - buf);
-            memmove(buf, match + 1, nread + 1);
-            ALOGV("supplicant generated event without interface - %s\n", buf);
-        }
-    } else {
-        /* let the event go as is! */
-        ALOGW("supplicant generated event without interface and without message level - %s\n", buf);
-    }
-    LOGI("EVENT: %s\n", buf);
-    return nread;
-}
-
-int wifi_wait_for_event(char *buf, size_t buflen)
-{
-    return wifi_wait_on_socket(buf, buflen);
-}
-
-void wifi_close_sockets()
-{
-    if (ctrl_conn != NULL) {
-        wpa_ctrl_close(ctrl_conn);
-        ctrl_conn = NULL;
-    }
-
-    if (monitor_conn != NULL) {
-        wpa_ctrl_close(monitor_conn);
-        monitor_conn = NULL;
-    }
-
-    if (exit_sockets[0] >= 0) {
-        close(exit_sockets[0]);
-        exit_sockets[0] = -1;
-    }
-
-    if (exit_sockets[1] >= 0) {
-        close(exit_sockets[1]);
-        exit_sockets[1] = -1;
-    }
-}
-
-void wifi_close_supplicant_connection()
-{
-    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
-    int count = 50; /* wait at most 5 seconds to ensure init has stopped stupplicant */
-    LOGD("Close connection to supplicant\n");
-    pthread_mutex_lock(&suppl_mutex);
-
-    wifi_close_sockets();
-        pthread_mutex_unlock(&suppl_mutex);
-
-    while (count-- > 0) {
-        if (property_get(supplicant_prop_name, supp_status, NULL)) {
-            if (strcmp(supp_status, "stopped") == 0) {
-                pthread_mutex_unlock(&suppl_mutex);
-                return;
-	    }
-        }
-        usleep(100000);
-    }
-    pthread_mutex_unlock(&suppl_mutex);
-}
-
-int wifi_command(const char *command, char *reply, size_t *reply_len)
-{
-    return wifi_send_command(command, reply, reply_len);
-}
-
 const char *wifi_get_fw_path(int fw_type)
 {
     char bcm_prop_chip[PROPERTY_VALUE_MAX];
@@ -856,4 +217,3 @@ int wifi_switch_driver_mode(int mode)
         return -1;
     }
 }
-
diff --git a/wifi/wifi.h b/wifi/wifi.h
index ccaa1e3..d738b58 100644
--- a/wifi/wifi.h
+++ b/wifi/wifi.h
@@ -65,6 +65,9 @@
 #define WIFI_DRIVER_FW_PATH_PARAM	"/sys/module/wlan/parameters/fwpath"
 #endif
 
+#define DRIVER_PROP_NAME "wlan.driver.status"
+#define VENDOR_PROP_NAME "wlan.driver.vendor"
+
 #define WIFI_MODULE_43241_OPMODE	"/sys/module/bcm43241/parameters/op_mode"
 #define WIFI_MODULE_4334_OPMODE		"/sys/module/bcm4334/parameters/op_mode"
 #define WIFI_MODULE_4335_OPMODE		"/sys/module/bcm4335/parameters/op_mode"
-- 
1.7.4.1

